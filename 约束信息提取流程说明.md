# xpgfuzz 约束信息提取流程说明

## 概述

约束信息是从 LLM 生成的协议模板中提取的类型和范围限制，用于指导后续的模糊测试变异。本文档详细说明约束信息的提取流程。

## 约束格式

LLM 输出的模板使用特殊标记 `<<...>>` 来表示约束信息，格式如下：

```
COMMAND: ["COMMAND <<TYPE:PARAMS>>\r\n"]
```

### 支持的约束类型

1. **INTEGER**: `<<INTEGER:min-max>>` - 整数范围约束
   - 示例: `<<INTEGER:0-65535>>`, `<<INTEGER:1-256>>`
   
2. **STRING**: `<<STRING:min_len-max_len>>` - 字符串长度约束
   - 示例: `<<STRING:1-256>>`, `<<STRING:1-512>>`
   
3. **ENUM**: `<<ENUM:val1,val2,val3>>` - 枚举值约束
   - 示例: `<<ENUM:GET,POST,PUT>>`, `<<ENUM:S,B,C>>`
   
4. **IP**: `<<IP>>` - IP地址约束
   
5. **PATH**: `<<PATH>>` - 文件路径约束
   
6. **HEX**: `<<HEX>>` - 十六进制值约束
   
7. **VALUE**: `<<VALUE>>` - 无约束值（向后兼容）

## 提取流程

### 阶段1: LLM 模板生成

LLM 根据协议规范生成模板，例如：

```json
["PORT <<INTEGER:0-255>>,<<INTEGER:0-255>>,<<INTEGER:0-255>>,<<INTEGER:0-255>>,<<INTEGER:0-255>>,<<INTEGER:0-255>>\r\n"]
```

### 阶段2: 正则表达式匹配

使用 PCRE2 正则表达式匹配约束标记：

**正则表达式**: `(?:(.*)(?:<<(.*)>>)(.*))|(.+)`

**匹配逻辑**:
- **第一个选项** `(.*)(?:<<(.*)>>)(.*)`: 匹配包含约束标记的字符串
  - 组1: 约束前的文本
  - 组2: 约束内容（如 `INTEGER:0-65535`）
  - 组3: 约束后的文本
- **第二个选项** `(.+)`: 匹配没有约束标记的字符串

**代码位置**: `chat-llm.c` 第767行

```c
pcre2_code *replacer = pcre2_compile("(?:(.*)(?:<<(.*)>>)(.*))|(.+)", 
                                     PCRE2_ZERO_TERMINATED, 
                                     PCRE2_DOTALL, 
                                     &errornumber, 
                                     &erroroffset, 
                                     NULL);
```

### 阶段3: 约束字符串提取

在 `parse_pattern()` 函数中（`chat-llm.c` 第660-717行），当正则匹配成功时：

1. **匹配到约束标记** (`rc == 4`):
   - 提取组2中的约束字符串（如 `INTEGER:0-65535`）
   - 调用 `extract_constraint_from_match()` 提取约束

```c
if (rc == 4) { // matched the first option - there is a special value
    // Extract constraint from the matched value (group 2)
    if (out_constraint) {
        *out_constraint = extract_constraint_from_match(str, ovector[4], ovector[5]);
    }
    // ... 构建正则模式 ...
}
```

2. **未匹配到约束标记** (`rc == 5`):
   - 设置约束为 `NULL`，表示无约束

### 阶段4: 约束解析

`extract_constraint_from_match()` 函数（`chat-llm.c` 第645-658行）：
- 从匹配的字符串中提取约束部分
- 调用 `parse_constraint()` 解析约束字符串

`parse_constraint()` 函数（`chat-llm.c` 第1595-1730行）根据约束类型进行解析：

#### 1. INTEGER 约束解析

```c
if (strncmp(constraint_str, "INTEGER:", 8) == 0) {
    constraint->type = CONSTRAINT_INTEGER;
    const char *range = constraint_str + 8;  // 跳过 "INTEGER:"
    char *dash = strchr(range, '-');
    if (dash) {
        constraint->constraint.integer_range.min = atoi(range);
        constraint->constraint.integer_range.max = atoi(dash + 1);
    } else {
        // 默认范围 0-65535
        constraint->constraint.integer_range.min = 0;
        constraint->constraint.integer_range.max = 65535;
    }
}
```

**示例**:
- 输入: `INTEGER:0-65535`
- 输出: `type = CONSTRAINT_INTEGER, min = 0, max = 65535`

#### 2. STRING 约束解析

```c
if (strncmp(constraint_str, "STRING:", 7) == 0) {
    constraint->type = CONSTRAINT_STRING;
    const char *range = constraint_str + 7;  // 跳过 "STRING:"
    char *dash = strchr(range, '-');
    if (dash) {
        constraint->constraint.string_range.min_len = atoi(range);
        constraint->constraint.string_range.max_len = atoi(dash + 1);
    } else {
        // 默认长度 1-256
        constraint->constraint.string_range.min_len = 1;
        constraint->constraint.string_range.max_len = 256;
    }
}
```

**示例**:
- 输入: `STRING:1-256`
- 输出: `type = CONSTRAINT_STRING, min_len = 1, max_len = 256`

#### 3. ENUM 约束解析

```c
if (strncmp(constraint_str, "ENUM:", 5) == 0) {
    constraint->type = CONSTRAINT_ENUM;
    const char *values = constraint_str + 5;  // 跳过 "ENUM:"
    
    // 统计逗号数量确定值的个数
    int count = 1;
    const char *p = values;
    while (*p) {
        if (*p == ',') count++;
        p++;
    }
    
    constraint->constraint.enum_values.count = count;
    constraint->constraint.enum_values.values = (char **)ck_alloc(count * sizeof(char *));
    
    // 解析每个值
    char *values_copy = strdup(values);
    char *token = strtok(values_copy, ",");
    int i = 0;
    while (token && i < count) {
        // 去除空白字符
        while (*token == ' ') token++;
        char *end_token = token + strlen(token) - 1;
        while (end_token > token && *end_token == ' ') *end_token-- = '\0';
        
        constraint->constraint.enum_values.values[i] = strdup(token);
        token = strtok(NULL, ",");
        i++;
    }
    free(values_copy);
}
```

**示例**:
- 输入: `ENUM:GET,POST,PUT`
- 输出: `type = CONSTRAINT_ENUM, count = 3, values = ["GET", "POST", "PUT"]`

#### 4. IP 约束解析

```c
if (strcmp(constraint_str, "IP") == 0) {
    constraint->type = CONSTRAINT_IP;
}
```

#### 5. PATH 约束解析

```c
if (strcmp(constraint_str, "PATH") == 0) {
    constraint->type = CONSTRAINT_PATH;
}
```

#### 6. HEX 约束解析

```c
if (strcmp(constraint_str, "HEX") == 0) {
    constraint->type = CONSTRAINT_HEX;
}
```

### 阶段5: 约束存储

提取的约束信息存储在两个位置：

1. **Header 约束**: 存储在 `header_constraints` 数组中
   - 代码位置: `chat-llm.c` 第816-825行

2. **Field 约束**: 存储在 `field_constraints` 数组中
   - 代码位置: `chat-llm.c` 第896-904行

3. **模式关联**: 通过 `store_pattern_constraints()` 将约束与模式关联
   - 代码位置: `chat-llm.c` 第726-744行
   - 使用 `pattern_constraints_storage` 哈希表存储

### 阶段6: 约束使用

在变异阶段（`mutate_value_by_constraint()` 函数，`chat-llm.c` 第1944-2600行），约束信息用于：

1. **生成符合约束的值**
   - INTEGER: 在范围内生成随机整数
   - STRING: 生成指定长度范围的字符串
   - ENUM: 从枚举值中随机选择
   - IP: 生成有效的IP地址
   - PATH: 生成文件路径
   - HEX: 生成十六进制值

2. **指导变异策略**
   - 边界值测试（min, max, min+1, max-1）
   - 溢出测试（min-1, max+1）
   - 特殊值测试（0, -1, 空值等）

## 完整示例

### LLM 输出示例

```
PORT: ["PORT <<INTEGER:0-255>>,<<INTEGER:0-255>>,<<INTEGER:0-255>>,<<INTEGER:0-255>>,<<INTEGER:0-255>>,<<INTEGER:0-255>>\r\n"]
```

### 提取过程

1. **正则匹配**:
   - 匹配到: `PORT <<INTEGER:0-255>>,<<INTEGER:0-255>>,...`
   - 提取约束字符串: `INTEGER:0-255`

2. **约束解析**:
   - 类型: `CONSTRAINT_INTEGER`
   - 范围: `min = 0, max = 255`

3. **模式构建**:
   - Header 模式: `^(?:PORT (.*)\r\n)`
   - Fields 模式: `(?|...)`
   - 约束关联: 每个捕获组对应一个约束

4. **变异使用**:
   - 生成值: `192`, `0`, `255`, `256` (边界测试) 等

## 约束数据结构

定义在 `chat-llm.h` 中：

```c
typedef enum {
    CONSTRAINT_NONE,    // <<VALUE>>
    CONSTRAINT_INTEGER, // <<INTEGER:min-max>>
    CONSTRAINT_STRING,  // <<STRING:min_len-max_len>>
    CONSTRAINT_ENUM,    // <<ENUM:val1,val2,...>>
    CONSTRAINT_IP,      // <<IP>>
    CONSTRAINT_PATH,    // <<PATH>>
    CONSTRAINT_HEX      // <<HEX>>
} constraint_type_t;

typedef struct {
    constraint_type_t type;
    union {
        struct { int min; int max; } integer_range;
        struct { int min_len; int max_len; } string_range;
        struct { char **values; int count; } enum_values;
    } constraint;
} type_constraint_t;
```

## 关键函数

| 函数名 | 位置 | 功能 |
|--------|------|------|
| `parse_pattern()` | `chat-llm.c:660` | 使用正则匹配提取约束标记 |
| `extract_constraint_from_match()` | `chat-llm.c:645` | 从匹配结果中提取约束字符串 |
| `parse_constraint()` | `chat-llm.c:1595` | 解析约束字符串为约束结构 |
| `store_pattern_constraints()` | `chat-llm.c:726` | 存储约束与模式的关联 |
| `mutate_value_by_constraint()` | `chat-llm.c:1944` | 根据约束进行变异 |

## 改进点

根据最新的增强改进：

1. **字段格式标准化**: 在提取约束前，使用 `normalize_field_string()` 标准化字段格式
2. **容错处理**: 即使部分字段约束提取失败，也会继续处理其他字段
3. **约束验证**: 确保提取的约束信息格式正确

## 总结

约束信息提取是一个多阶段过程：
1. LLM 生成带约束标记的模板
2. 正则表达式匹配约束标记
3. 提取约束字符串
4. 解析约束类型和参数
5. 存储约束信息
6. 在变异阶段使用约束指导测试生成

这个流程确保了从 LLM 输出中准确提取类型和范围信息，为基于约束的变异提供了基础。

